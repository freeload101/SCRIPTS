#!/usr/bin/env python3
"""
Interactive JSON to XLSX Converter - Explore paths and export selected ones to Excel
"""

import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Set
from collections import OrderedDict
import openpyxl
from openpyxl.styles import Font, PatternFill, Alignment
from openpyxl.utils import get_column_letter


def is_blank(value: Any) -> bool:
    """Check if value is null, empty string, or whitespace-only string"""
    if value is None:
        return True
    if isinstance(value, str) and not value.strip():
        return True
    return False


def format_for_excel(value: Any) -> str:
    """Format value for human-readable Excel output"""
    if isinstance(value, list):
        if all(isinstance(item, (str, int, float, bool)) for item in value):
            return '\n'.join(str(item) for item in value)
        else:
            return json.dumps(value, indent=2)
    elif isinstance(value, dict):
        return json.dumps(value, indent=2)
    elif value is None:
        return ''
    return str(value)


def explore_json(data: Any, path: str = "$", results: Dict[str, Any] = None, seen_paths: Set[str] = None) -> Dict[str, Any]:
    """Recursively explore JSON and collect first non-blank value for each unique path"""
    if results is None:
        results = OrderedDict()
    if seen_paths is None:
        seen_paths = set()

    if isinstance(data, dict):
        for key, value in data.items():
            new_path = f"{path}.{key}"

            if new_path not in seen_paths and not is_blank(value):
                if not isinstance(value, (dict, list)):
                    results[new_path] = value
                    seen_paths.add(new_path)

            explore_json(value, new_path, results, seen_paths)

    elif isinstance(data, list):
        for item in data:
            array_path = f"{path}[*]"
            explore_json(item, array_path, results, seen_paths)

    else:
        if path not in seen_paths and not is_blank(data):
            results[path] = data
            seen_paths.add(path)

    return results


def extract_value_by_path(data: Any, path: str) -> Any:
    """Extract value from data using a path like $.users[*].name"""
    parts = path.replace('$', '').split('.')
    parts = [p for p in parts if p]

    current = data
    for part in parts:
        if '[*]' in part:
            part = part.replace('[*]', '')
            if part:
                current = current.get(part) if isinstance(current, dict) else None
            return current
        else:
            if isinstance(current, dict):
                current = current.get(part)
            else:
                return None

    return current


def flatten_data(data: Any, selected_paths: List[str]) -> List[Dict[str, Any]]:
    """Flatten JSON data based on selected paths, handling arrays intelligently"""
    rows = []
    array_paths = [p for p in selected_paths if '[*]' in p]

    if not array_paths:
        row = {}
        for path in selected_paths:
            value = extract_value_by_path(data, path)
            col_name = path.replace('$', '').replace('.', ' ').replace('[*]', '').strip()
            col_name = ' '.join(word.capitalize() for word in col_name.split())

            row[col_name] = format_for_excel(value)
        rows.append(row)
    else:
        base_array_path = array_paths[0].split('[*]')[0] + '[*]'
        array_data = extract_value_by_path(data, base_array_path)

        if not isinstance(array_data, list):
            array_data = [array_data] if array_data else []

        for item in array_data:
            row = {}
            for path in selected_paths:
                if '[*]' in path:
                    sub_path = path.split('[*]', 1)[1]
                    if sub_path.startswith('.'):
                        sub_path = '$' + sub_path
                    else:
                        sub_path = '$'
                    value = extract_value_by_path(item, sub_path)
                else:
                    value = extract_value_by_path(data, path)

                col_name = path.replace('$', '').replace('[*]', '').replace('.', ' ').strip()
                col_name = ' '.join(word.capitalize() for word in col_name.split())

                row[col_name] = format_for_excel(value)

            rows.append(row)

    # Remove duplicates for values longer than 255 chars
    seen = set()
    unique_rows = []
    for row in rows:
        row_key = tuple(
            (k, v[:255] if isinstance(v, str) and len(v) > 255 else v)
            for k, v in sorted(row.items())
        )
        if row_key not in seen:
            seen.add(row_key)
            unique_rows.append(row)

    return unique_rows


def format_value(value: Any) -> str:
    """Format value for display in terminal"""
    if isinstance(value, str):
        if len(value) > 80:
            return f'"{value[:77]}..."'
        return f'"{value}"'
    elif isinstance(value, list):
        if len(value) <= 3:
            return f"[{', '.join(str(v) for v in value)}]"
        return f"[{', '.join(str(v) for v in value[:3])}, ...]"
    elif isinstance(value, dict):
        return "{...}"
    return str(value)


def display_paths(paths: Dict[str, Any], selected: Set[int]):
    """Display paths with selection indicators"""
    print("\n" + "=" * 100)
    print("Available JSON Paths (Use ↑/↓ arrows, SPACE to select, ENTER to export)")
    print("=" * 100)

    max_num_len = len(str(len(paths)))
    max_path_len = min(max(len(path) for path in paths.keys()), 50)

    for idx, (path, value) in enumerate(paths.items(), 1):
        check = "[✓]" if idx in selected else "[ ]"
        formatted_value = format_value(value)
        truncated_path = path if len(path) <= 50 else path[:47] + "..."
        print(f"{check} {idx:>{max_num_len}}. {truncated_path:<{max_path_len}} : {formatted_value}")

    print("=" * 100)


def interactive_selection(paths: Dict[str, Any]) -> List[int]:
    """Interactive path selection with arrow keys and spacebar"""
    try:
        import curses

        def selection_menu(stdscr):
            curses.curs_set(0)
            current_row = 0
            selected = set()
            path_list = list(paths.items())

            while True:
                stdscr.clear()
                h, w = stdscr.getmaxyx()

                stdscr.addstr(0, 0, "JSON Path Selection", curses.A_BOLD)
                stdscr.addstr(1, 0, "↑/↓: Navigate | SPACE: Toggle | ENTER: Export | Q: Quit", curses.A_DIM)
                stdscr.addstr(2, 0, "-" * min(w-1, 100))

                start_row = max(0, current_row - (h - 6))
                end_row = min(len(path_list), start_row + (h - 6))

                for idx in range(start_row, end_row):
                    path, value = path_list[idx]
                    check = "[✓]" if idx + 1 in selected else "[ ]"
                    formatted_value = format_value(value)
                    line = f"{check} {idx + 1}. {path}: {formatted_value}"

                    if len(line) > w - 1:
                        line = line[:w-4] + "..."

                    y_pos = 3 + (idx - start_row)
                    if idx == current_row:
                        stdscr.addstr(y_pos, 0, line, curses.A_REVERSE)
                    else:
                        stdscr.addstr(y_pos, 0, line)

                stdscr.addstr(h-1, 0, f"Selected: {len(selected)} | Total: {len(path_list)}", curses.A_DIM)

                key = stdscr.getch()

                if key == curses.KEY_UP and current_row > 0:
                    current_row -= 1
                elif key == curses.KEY_DOWN and current_row < len(path_list) - 1:
                    current_row += 1
                elif key == ord(' '):
                    if current_row + 1 in selected:
                        selected.remove(current_row + 1)
                    else:
                        selected.add(current_row + 1)
                elif key == ord('\n'):
                    return sorted(list(selected)) if selected else None
                elif key in (ord('q'), ord('Q')):
                    return None

        return curses.wrapper(selection_menu)

    except ImportError:
        print("Curses not available, falling back to simple selection")
        return get_user_selection(len(paths))


def get_user_selection(total_paths: int) -> List[int]:
    """Fallback text-based selection"""
    print("\nSelect paths to export to XLSX:")
    print("  - Enter numbers separated by commas (e.g., 1,3,5)")
    print("  - Enter ranges with dash (e.g., 1-5)")
    print("  - Enter 'all' to select all paths")
    print("  - Enter 'q' to quit")

    while True:
        user_input = input("\nYour selection: ").strip().lower()

        if user_input == 'q':
            return None

        if user_input == 'all':
            return list(range(1, total_paths + 1))

        try:
            selected = set()
            parts = user_input.split(',')

            for part in parts:
                part = part.strip()
                if '-' in part:
                    start, end = part.split('-')
                    start, end = int(start.strip()), int(end.strip())
                    if 1 <= start <= total_paths and 1 <= end <= total_paths:
                        selected.update(range(start, end + 1))
                else:
                    num = int(part)
                    if 1 <= num <= total_paths:
                        selected.add(num)

            if selected:
                return sorted(list(selected))
            else:
                print("No valid selections. Try again.")

        except ValueError:
            print("Invalid input. Please use format like: 1,2,5 or 1-10 or 'all'")


def write_xlsx(output_file: Path, rows: List[Dict[str, Any]]):
    """Write data to XLSX with formatting"""
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Data"

    if not rows:
        wb.save(output_file)
        return

    headers = list(rows[0].keys())

    # Write headers with formatting
    header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
    header_font = Font(bold=True, color="FFFFFF")

    for col_idx, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col_idx, value=header)
        cell.fill = header_fill
        cell.font = header_font

    # Write data with text wrapping for multi-line content
    for row_idx, row in enumerate(rows, 2):
        for col_idx, header in enumerate(headers, 1):
            value = row.get(header, '')
            cell = ws.cell(row=row_idx, column=col_idx, value=value)

            # Enable text wrapping and top alignment for cells with newlines
            if isinstance(value, str) and '\n' in value:
                cell.alignment = Alignment(wrap_text=True, vertical='top')

    # Auto-adjust column widths
    for col_idx, header in enumerate(headers, 1):
        max_length = len(str(header))
        for row in rows:
            cell_value = str(row.get(header, ''))
            # For multi-line content, use the longest line
            if '\n' in cell_value:
                max_line = max(len(line) for line in cell_value.split('\n'))
                max_length = max(max_length, min(max_line, 50))
            else:
                max_length = max(max_length, min(len(cell_value), 50))
        ws.column_dimensions[get_column_letter(col_idx)].width = max_length + 2

    wb.save(output_file)


def main():
    if len(sys.argv) < 2:
        print("Usage: python json_to_xlsx.py <json_file> [output.xlsx]")
        sys.exit(1)

    json_file = Path(sys.argv[1])
    output_file = Path(sys.argv[2]) if len(sys.argv) > 2 else json_file.with_suffix('.xlsx')

    if not json_file.exists():
        print(f"Error: File '{json_file}' not found")
        sys.exit(1)

    try:
        with open(json_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON - {e}")
        sys.exit(1)

    print(f"Loaded: {json_file}")

    paths = explore_json(data)

    if not paths:
        print("No non-blank values found in JSON")
        return

    selected_indices = interactive_selection(paths)

    if selected_indices is None:
        print("Cancelled.")
        return

    path_list = list(paths.keys())
    selected_paths = [path_list[i - 1] for i in selected_indices]

    print(f"\nSelected {len(selected_paths)} path(s)")

    rows = flatten_data(data, selected_paths)

    if not rows:
        print("No data to export")
        return

    print(f"Writing to: {output_file}")
    write_xlsx(output_file, rows)

    print(f"\n✓ Successfully exported {len(rows)} row(s) to {output_file}")


if __name__ == "__main__":
    main()
