#Requires -RunAsAdministrator
#  does not dump important stuff just lame stuff and top 10 processes 


# Remove existing type if present
if ([System.Management.Automation.PSTypeName]'MemoryDumper'.Type) {
    Write-Host "[*] Removing existing MemoryDumper type..." -ForegroundColor Yellow
    Remove-Variable -Name MemoryDumper -ErrorAction SilentlyContinue
}

$csharpCode = @"
using System;
using System.Runtime.InteropServices;
using System.ComponentModel;

public class MemoryDumper
{
    [DllImport("dbghelp.dll", SetLastError = true)]
    private static extern bool MiniDumpWriteDump(
        IntPtr hProcess,
        uint ProcessId,
        IntPtr hFile,
        int DumpType,
        IntPtr ExceptionParam,
        IntPtr UserStreamParam,
        IntPtr CallbackParam
    );

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr OpenProcess(
        uint processAccess,
        bool bInheritHandle,
        int processId
    );

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern IntPtr CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile
    );

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool CloseHandle(IntPtr hObject);

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool AdjustTokenPrivileges(
        IntPtr TokenHandle,
        bool DisableAllPrivileges,
        ref TOKEN_PRIVILEGES NewState,
        int BufferLength,
        IntPtr PreviousState,
        IntPtr ReturnLength
    );

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool OpenProcessToken(
        IntPtr ProcessHandle,
        uint DesiredAccess,
        out IntPtr TokenHandle
    );

    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern bool LookupPrivilegeValue(
        string lpSystemName,
        string lpName,
        out LUID lpLuid
    );

    [DllImport("kernel32.dll")]
    private static extern IntPtr GetCurrentProcess();

    [StructLayout(LayoutKind.Sequential)]
    private struct LUID
    {
        public uint LowPart;
        public int HighPart;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct TOKEN_PRIVILEGES
    {
        public int PrivilegeCount;
        public LUID Luid;
        public int Attributes;
    }

    private const int SE_PRIVILEGE_ENABLED = 0x00000002;
    private const uint TOKEN_ADJUST_PRIVILEGES = 0x0020;
    private const uint TOKEN_QUERY = 0x0008;
    private const uint PROCESS_ALL_ACCESS = 0x1F0FFF;
    private const uint GENERIC_WRITE = 0x40000000;
    private const uint FILE_SHARE_WRITE = 0x2;
    private const uint CREATE_ALWAYS = 2;
    private const int MiniDumpWithFullMemory = 0x00000002;

    public static bool EnablePrivilege(string privilegeName)
    {
        IntPtr token;
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, out token))
        {
            throw new Win32Exception(Marshal.GetLastWin32Error());
        }

        LUID luid;
        if (!LookupPrivilegeValue(null, privilegeName, out luid))
        {
            CloseHandle(token);
            throw new Win32Exception(Marshal.GetLastWin32Error());
        }

        TOKEN_PRIVILEGES tp = new TOKEN_PRIVILEGES
        {
            PrivilegeCount = 1,
            Luid = luid,
            Attributes = SE_PRIVILEGE_ENABLED
        };

        if (!AdjustTokenPrivileges(token, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero))
        {
            CloseHandle(token);
            throw new Win32Exception(Marshal.GetLastWin32Error());
        }

        CloseHandle(token);
        return true;
    }

    public static void DumpProcess(int processId, string dumpFilePath)
    {
        IntPtr processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, processId);
        if (processHandle == IntPtr.Zero)
        {
            throw new Win32Exception(Marshal.GetLastWin32Error(), "Failed to open process");
        }

        IntPtr fileHandle = CreateFile(
            dumpFilePath,
            GENERIC_WRITE,
            FILE_SHARE_WRITE,
            IntPtr.Zero,
            CREATE_ALWAYS,
            0,
            IntPtr.Zero
        );

        if (fileHandle == IntPtr.Zero || fileHandle.ToInt64() == -1)
        {
            CloseHandle(processHandle);
            throw new Win32Exception(Marshal.GetLastWin32Error(), "Failed to create dump file");
        }

        bool success = MiniDumpWriteDump(
            processHandle,
            (uint)processId,
            fileHandle,
            MiniDumpWithFullMemory,
            IntPtr.Zero,
            IntPtr.Zero,
            IntPtr.Zero
        );

        CloseHandle(fileHandle);
        CloseHandle(processHandle);

        if (!success)
        {
            throw new Win32Exception(Marshal.GetLastWin32Error(), "MiniDumpWriteDump failed");
        }
    }
}
"@

try {
    Add-Type -TypeDefinition $csharpCode -Language CSharp -ErrorAction Stop
    Write-Host "[+] MemoryDumper type loaded successfully`n" -ForegroundColor Green
}
catch {
    Write-Error "Failed to compile C# code: $_"
    exit
}

function Invoke-SystemMemoryDump {
    param(
        [Parameter(Mandatory=$false)]
        [string]$OutputDir = "$env:TEMP\MemoryDumps"
    )

    Write-Host "[*] System Memory Dump Utility" -ForegroundColor Cyan
    Write-Host "[*] ============================`n" -ForegroundColor Cyan

    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        Write-Error "This script requires Administrator privileges"
        return
    }

    if (-not (Test-Path $OutputDir)) {
        New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null
    }

    Write-Host "[*] Enabling required privileges..." -ForegroundColor Cyan
    try {
        [MemoryDumper]::EnablePrivilege("SeDebugPrivilege")
        [MemoryDumper]::EnablePrivilege("SeBackupPrivilege")
        Write-Host "[+] Privileges enabled`n" -ForegroundColor Green
    }
    catch {
        Write-Error "Failed to enable privileges: $_"
        return
    }

    Write-Host "[*] Enumerating system processes..." -ForegroundColor Cyan
    $processes = Get-Process | Where-Object { $_.Id -ne 0 -and $_.Id -ne 4 } | Sort-Object WorkingSet64 -Descending

    $totalMemory = (Get-CimInstance Win32_OperatingSystem).TotalVisibleMemorySize / 1MB
    Write-Host "[+] Total System Memory: $([math]::Round($totalMemory, 2)) GB`n" -ForegroundColor Green

    Write-Host "[*] Dumping critical system processes..." -ForegroundColor Cyan

    $criticalProcesses = @('lsass', 'csrss', 'services', 'winlogon', 'smss', 'wininit')
    $dumpedSize = 0

    foreach ($procName in $criticalProcesses) {
        $proc = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($proc) {
            $dumpFile = Join-Path $OutputDir "$($proc.Name)_$($proc.Id)_$(Get-Date -Format 'yyyyMMdd_HHmmss').dmp"

            try {
                Write-Host "  [*] Dumping $($proc.Name) (PID: $($proc.Id), Memory: $([math]::Round($proc.WorkingSet64/1MB, 2)) MB)..." -ForegroundColor Yellow
                [MemoryDumper]::DumpProcess($proc.Id, $dumpFile)

                $fileSize = (Get-Item $dumpFile).Length / 1MB
                $dumpedSize += $fileSize
                Write-Host "  [+] Saved: $([math]::Round($fileSize, 2)) MB" -ForegroundColor Green
            }
            catch {
                Write-Host "  [-] Failed: $_" -ForegroundColor Red
            }
        }
    }

    Write-Host "`n[*] Dumping top 10 memory-consuming processes..." -ForegroundColor Cyan
    $topProcesses = $processes | Select-Object -First 10

    foreach ($proc in $topProcesses) {
        if ($criticalProcesses -contains $proc.Name) { continue }

        $dumpFile = Join-Path $OutputDir "$($proc.Name)_$($proc.Id)_$(Get-Date -Format 'yyyyMMdd_HHmmss').dmp"

        try {
            Write-Host "  [*] Dumping $($proc.Name) (PID: $($proc.Id), Memory: $([math]::Round($proc.WorkingSet64/1MB, 2)) MB)..." -ForegroundColor Yellow
            [MemoryDumper]::DumpProcess($proc.Id, $dumpFile)

            $fileSize = (Get-Item $dumpFile).Length / 1MB
            $dumpedSize += $fileSize
            Write-Host "  [+] Saved: $([math]::Round($fileSize, 2)) MB" -ForegroundColor Green
        }
        catch {
            Write-Host "  [-] Failed: $_" -ForegroundColor Red
        }
    }

    Write-Host "`n[+] Memory dump complete!" -ForegroundColor Green
    Write-Host "[*] Total dumped: $([math]::Round($dumpedSize, 2)) MB" -ForegroundColor Cyan
    Write-Host "[*] Output directory: $OutputDir" -ForegroundColor Cyan
}

Invoke-SystemMemoryDump
